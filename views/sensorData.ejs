<div class="container">
  <h1>æ¸©åº¦ã‚»ãƒ³ã‚µãƒ¼ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ </h1>
  
  <!-- Tab Navigation -->
  <div class="tab-container">
    <div class="tab-nav">
      <button class="tab-button" id="sensorTabBtn" onclick="switchTab('sensorTab', this)">
        <span class="tab-icon">ğŸ“Š</span>
        <span>ã‚»ãƒ³ã‚µãƒ¼çŠ¶æ…‹</span>
      </button>
      <button class="tab-button" id="serverTabBtn" onclick="switchTab('serverTab', this)">
        <span class="tab-icon">ğŸ–¥ï¸</span>
        <span>ã‚µãƒ¼ãƒãƒ¼æƒ…å ±</span>
      </button>
    </div>

    <!-- Sensor Tab Content -->
    <div id="sensorTab" class="tab-content">
      <div class="sensor-panels">
        <% latestReadings.forEach((sensor, index) => { %>
          <div class="sensor-data-section" id="sensor-<%= sensor.sensorId %>">
            <div class="sensor-header">
              <h2 class="sensor-title">
                <span class="sensor-icon">ğŸŒ¡ï¸</span>
                <%= sensor.sensorId %> ã‚»ãƒ³ã‚µãƒ¼æƒ…å ±
              </h2>
              <div class="sensor-status <%= sensor.isActive ? 'active' : 'inactive' %>">
                <%= sensor.isActive ? 'ç¨¼åƒä¸­' : 'åœæ­¢ä¸­' %>
              </div>
            </div>
            
            <!-- Raw Data History -->
            <div class="sensor-data-section">
             
              <div class="section-controls">
                <h3>å–å¾—ãƒ‡ãƒ¼ã‚¿å±¥æ­´ <span class="data-count">(æœ€æ–°100ä»¶)</span></h3>
                <button class="refresh-btn" onclick="refreshData('<%= sensor.sensorId %>')">
                  <span class="refresh-icon">ğŸ”„</span>
                </button>
              </div>
              <div class="table-wrapper">
                <table class="data-table">
                  <thead>
                    <tr>
                      <th>å¹´æœˆæ—¥</th>
                      <th>æ™‚åˆ»</th>
                      <% for(let i = 1; i <= 16; i++) { %>
                      <th><%= i %></th>
                      <% } %>
                      <th>å¹³å‡æ¸©åº¦</th>
                      <th>çŠ¶æ…‹</th>
                    </tr>
                  </thead>
                  <tbody id="tbody-<%= sensor.sensorId %>">
                    <% sensor.data.forEach(data => { %>
                    <tr class="<%= data.isAbnormal ? 'table-danger' : '' %>">
                      <td><%= data.acquisitionDate %></td>
                      <td><%= data.acquisitionTime %></td>
                      <% data.temperatures.forEach(temp => { %>
                      <td><%= temp !== null ? temp.toFixed(1) : '--' %></td>
                      <% }); %>
                      <td><%= data.averageTemperature !== null ? data.averageTemperature.toFixed(1) : '--' %> Â°C</td>
                      <td><%= data.isAbnormal ? 'ç•°å¸¸' : 'æ­£å¸¸' %></td>
                    </tr>
                    <% }); %>
                  </tbody>
                </table>
              </div>
            </div>
            
            <!-- Alert History -->
            <div class="section-header history-section-header">
              <h3>ã‚¢ãƒ©ãƒ¼ãƒˆå±¥æ­´ <span class="data-count">(æœ€æ–°10ä»¶)</span></h3>
              <button class="expand-btn" onclick="toggleTableExpand('alerts-<%= sensor.sensorId %>-wrapper')">
                <span class="toggle-icon">âŒ„</span><span class="toggle-text">å±•é–‹</span>
              </button>
            </div>
            <div class="table-wrapper alert-table" id="alerts-<%= sensor.sensorId %>-wrapper">
              <table class="data-table">
                <thead>
                  <tr>
                    <th>å–å¾—æ—¥</th>
                    <th>å–å¾—æ™‚åˆ»</th>
                    <th>ã‚¢ãƒ©ãƒ¼ãƒˆç™ºç”Ÿç†ç”±</th>
                  </tr>
                </thead>
                <tbody id="alerts-<%= sensor.sensorId %>">
                  <% (sensor.alerts || []).slice(0, 10).forEach(alert => { %>
                  <tr class="<%= alert.eventType?.includes('RECOVERY') ? 'alert-recovery' : 'alert-row' %>">
                    <td><%= alert.date || '-' %></td>
                    <td><%= alert.time || '-' %></td>
                    <td><%= alert.event || '-' %></td>
                  </tr>
                  <% }); %>
                  <% if ((sensor.alerts || []).length === 0) { %>
                    <tr class="empty-table-row">
                      <td colspan="3">ã‚¢ãƒ©ãƒ¼ãƒˆå±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“</td>
                    </tr>
                  <% } %>
                </tbody>
              </table>
            </div>
            
            <!-- Settings History -->
            <div class="section-header history-section-header">
              <h3>è¨­å®šå¤‰æ›´å±¥æ­´ <span class="data-count">(æœ€æ–°10ä»¶)</span></h3>
              <button class="expand-btn" onclick="toggleTableExpand('settings-<%= sensor.sensorId %>-wrapper')">
                <span class="toggle-icon">âŒ„</span><span class="toggle-text">å±•é–‹</span>
              </button>
            </div>
            <div class="table-wrapper settings-table" id="settings-<%= sensor.sensorId %>-wrapper">
              <table class="data-table">
                <thead>
                  <tr>
                    <th>æ—¥ä»˜</th>
                    <th>æ™‚åˆ»</th>
                    <th>è¨­å®šå†…å®¹</th>
                  </tr>
                </thead>
                <tbody id="settings-<%= sensor.sensorId %>">
                  <% (sensor.settings || []).forEach(setting => { %>
                  <tr>
                    <td><%= setting.date || '-' %></td>
                    <td><%= setting.time || '-' %></td>
                    <td><%= setting.content || '-' %></td>
                  </tr>
                  <% }); %>
                  <% if ((sensor.settings || []).length === 0) { %>
                    <tr class="empty-table-row">
                      <td colspan="3">è¨­å®šå¤‰æ›´å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“</td>
                    </tr>
                  <% } %>
                </tbody>
              </table>
            </div>
            
            <!-- Personality History -->
            <div class="section-header history-section-header">
              <h3>å€‹æ€§ï¼ˆãƒã‚¤ã‚¢ã‚¹ï¼‰å±¥æ­´ <span class="data-count">(æœ€æ–°10ä»¶)</span></h3>
              <button class="expand-btn" onclick="toggleTableExpand('personality-<%= sensor.sensorId %>-wrapper')">
                <span class="toggle-icon">âŒ„</span><span class="toggle-text">å±•é–‹</span>
              </button>
            </div>
            <div class="table-wrapper personality-table" id="personality-<%= sensor.sensorId %>-wrapper">
              <table class="data-table">
                <thead>
                  <tr>
                    <th>æ—¥ä»˜</th>
                    <th>æ™‚åˆ»</th>
                    <th>ãƒã‚¤ã‚¢ã‚¹è¨­å®š</th>
                  </tr>
                </thead>
                <tbody id="personality-<%= sensor.sensorId %>">
                  <% (sensor.personality || []).forEach(item => { %>
                  <tr>
                    <td><%= item.date || '-' %></td>
                    <td><%= item.time || '-' %></td>
                    <td><%= item.content || '-' %></td>
                  </tr>
                  <% }); %>
                  <% if ((sensor.personality || []).length === 0) { %>
                    <tr class="empty-table-row">
                      <td colspan="3">ãƒã‚¤ã‚¢ã‚¹è¨­å®šå±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“</td>
                    </tr>
                  <% } %>
                </tbody>
              </table>
            </div>
          </div>
        <% }); %>
      </div>
    </div>

    <!-- Server Tab Content -->
    <div id="serverTab" class="tab-content">
      <h2 class="server-title">ã‚µãƒ¼ãƒãƒ¼æƒ…å ±</h2>
      
      <div class="server-stats">
        <!-- System Status Card -->
        <div class="stat-card system-status">
          <div class="stat-header">
            <h3 class="stat-title">
              <span class="stat-icon">âš¡</span>
              ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹
            </h3>
            <span class="last-updated" id="status-last-updated">æœ€çµ‚æ›´æ–°: <%= serverStats.lastUpdateTime ? new Date(serverStats.lastUpdateTime).toLocaleString('ja-JP') : '-' %></span>
          </div>
          <div class="stat-content" id="system-status">
            <table class="data-table status-table">
              <tr>
                <th>MongoDBæ¥ç¶šçŠ¶æ…‹</th>
                <td id="mongodb-status">æ¥ç¶šä¸­</td>
              </tr>
              <tr>
                <th>ã‚»ãƒ³ã‚µãƒ¼æ•°</th>
                <td id="sensor-count"><%= serverStats.totalSensors %></td>
              </tr>
              <tr>
                <th>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒ³ã‚µãƒ¼</th>
                <td id="active-sensors"><%= serverStats.activeSensors %></td>
              </tr>
              <tr>
                <th>æœ€çµ‚ãƒ‡ãƒ¼ã‚¿å—ä¿¡</th>
                <td id="last-data-received"><%= serverStats.lastUpdateTime ? new Date(serverStats.lastUpdateTime).toLocaleString('ja-JP', {
                  year: 'numeric',
                  month: '2-digit',
                  day: '2-digit',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit'
                }) : '-' %></td>
              </tr>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Function to update sensor status
  function updateSensorStatus(sensorId, isActive) {
    const statusElement = document.querySelector(`#sensor-${sensorId} .sensor-status`);
    if (statusElement) {
      statusElement.className = `sensor-status ${isActive ? 'active' : 'inactive'}`;
      statusElement.textContent = isActive ? 'ç¨¼åƒä¸­' : 'åœæ­¢ä¸­';
      
      // Also update server status
      const activeCount = document.querySelectorAll('.sensor-status.active').length;
      const activeSensorsElement = document.getElementById('active-sensors');
      if (activeSensorsElement) {
        activeSensorsElement.textContent = activeCount;
      }
      
      // Update last data received time
      const lastDataElement = document.getElementById('last-data-received');
      if (lastDataElement) {
        lastDataElement.textContent = new Date().toLocaleString('ja-JP', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
      }
    }
  }

  // Function to update sensor data display
  function updateSensorData(data) {
    if (!data || !data.sensorId) {
      console.warn('Invalid sensor data received:', data);
      return;
    }
    
    console.log(`Processing sensor data update for ${data.sensorId}:`, data);
    
    const tbody = document.getElementById(`tbody-${data.sensorId}`);
    if (!tbody) {
      console.warn(`Table body element not found for sensor ${data.sensorId}`);
      return;
    }
    
    // Update sensor status
    const isActive = new Date(data.timestamp) > new Date(Date.now() - 5000);
    updateSensorStatus(data.sensorId, isActive);
    
    // Create a new row for the data
    const row = document.createElement('tr');
    row.className = data.isAbnormal ? 'table-danger' : '';
    
    // Format date and time
    const date = new Date(data.timestamp);
    const formattedDate = date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    }).replace(/\//g, '-');
    
    const formattedTime = date.toLocaleTimeString('ja-JP', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    });
    
    // Create row content
    let rowHTML = `
      <td>${formattedDate}</td>
      <td>${formattedTime}</td>
    `;
    
    // Add the 16 temperature readings
    if (data.temperatures && Array.isArray(data.temperatures)) {
      data.temperatures.forEach(temp => {
        const value = temp !== null && temp !== undefined ? parseFloat(temp).toFixed(1) : '--';
        rowHTML += `<td>${value}</td>`;
      });
      // Fill remaining slots if less than 16 readings
      for (let i = data.temperatures.length; i < 16; i++) {
        rowHTML += '<td>--</td>';
      }
    } else {
      // If no temperature data, fill all 16 slots with placeholder
      for (let i = 0; i < 16; i++) {
        rowHTML += '<td>--</td>';
      }
    }
    
    // Calculate average temperature from valid temperatures
    let avgTemp = '--';
    if (data.temperatures && Array.isArray(data.temperatures)) {
      const validTemps = data.temperatures.filter(t => t !== null && t !== undefined && !isNaN(parseFloat(t)));
      if (validTemps.length > 0) {
        const sum = validTemps.reduce((acc, curr) => acc + parseFloat(curr), 0);
        avgTemp = (sum / validTemps.length).toFixed(1);
      }
    }
    
    rowHTML += `
      <td>${avgTemp} Â°C</td>
      <td>${data.isAbnormal ? 'ç•°å¸¸' : 'æ­£å¸¸'}</td>
    `;
    
    row.innerHTML = rowHTML;
    
    // Check for empty state and remove it if it exists
    const emptyRow = tbody.querySelector('.empty-table-row');
    if (emptyRow) {
      tbody.removeChild(emptyRow);
    }
    
    // Add to the beginning of the table
    tbody.insertBefore(row, tbody.firstChild);
    
    // Keep only the latest 100 rows
    while (tbody.children.length > 100) {
      tbody.removeChild(tbody.lastChild);
    }
    
    console.log(`Updated sensor data display for ${data.sensorId}`);
  }
  
  // New function to handle full sensor dataset
  function handleFullSensorData(data) {
    if (!data || !data.sensorId || !Array.isArray(data.readings)) {
      console.warn('Invalid full sensor data received:', data);
      return;
    }
    
    console.log(`Received full dataset (${data.readings.length} readings) for sensor ${data.sensorId}`);
    
    const tbody = document.getElementById(`tbody-${data.sensorId}`);
    if (!tbody) {
      console.warn(`Table body element not found for sensor ${data.sensorId}`);
      return;
    }
    
    // Clear existing table data
    tbody.innerHTML = '';
    
    // Add all readings, newest first (they should already be sorted by timestamp)
    data.readings.forEach(reading => {
      updateSensorData(reading);
    });
    
    // Update sensor status based on most recent reading
    if (data.readings.length > 0) {
      const mostRecent = data.readings[0];
      const isActive = new Date(mostRecent.timestamp) > new Date(Date.now() - 5000);
      updateSensorStatus(data.sensorId, isActive);
    }
    
    console.log(`Updated display with full dataset for sensor ${data.sensorId}`);
  }
  
  // New function to handle alerts full dataset
  function handleFullAlertsData(alerts) {
    if (!Array.isArray(alerts)) {
      console.warn('Invalid alerts data received');
      return;
    }
    
    console.log(`Received full alerts dataset (${alerts.length} alerts)`);
    
    // Group alerts by sensorId
    const alertsBySensor = {};
    
    alerts.forEach(alert => {
      if (!alert.sensorId) return;
      
      if (!alertsBySensor[alert.sensorId]) {
        alertsBySensor[alert.sensorId] = [];
      }
      
      alertsBySensor[alert.sensorId].push(alert);
    });
    
    // Update each sensor's alerts table
    for (const [sensorId, sensorAlerts] of Object.entries(alertsBySensor)) {
      const alertsTable = document.getElementById(`alerts-${sensorId}`);
      if (!alertsTable) continue;
      
      // Clear existing alerts
      alertsTable.innerHTML = '';
      
      // Add all alerts, newest first
      sensorAlerts.forEach(alert => handleAlert(alert, false));
      
      console.log(`Updated alerts table for sensor ${sensorId} with ${sensorAlerts.length} alerts`);
    }
  }
  
  // New function to handle settings full dataset
  function handleFullSettingsData(settings) {
    if (!Array.isArray(settings)) {
      console.warn('Invalid settings data received');
      return;
    }
    
    console.log(`Received full settings dataset (${settings.length} settings)`);
    
    // Group settings by sensorId
    const settingsBySensor = {};
    
    settings.forEach(setting => {
      if (!setting.sensorId) return;
      
      if (!settingsBySensor[setting.sensorId]) {
        settingsBySensor[setting.sensorId] = [];
      }
      
      settingsBySensor[setting.sensorId].push(setting);
    });
    
    // Update each sensor's settings table
    for (const [sensorId, sensorSettings] of Object.entries(settingsBySensor)) {
      const settingsTable = document.getElementById(`settings-${sensorId}`);
      if (!settingsTable) continue;
      
      // Clear existing settings
      settingsTable.innerHTML = '';
      
      // Add all settings, newest first
      sensorSettings.forEach(setting => handleSettingChange(setting, false));
      
      console.log(`Updated settings table for sensor ${sensorId} with ${sensorSettings.length} settings`);
    }
  }
  
  // New function to handle personality full dataset
  function handleFullPersonalityData(personalities) {
    if (!Array.isArray(personalities)) {
      console.warn('Invalid personality data received');
      return;
    }
    
    console.log(`Received full personality dataset (${personalities.length} items)`);
    
    // Group personalities by sensorId
    const personalitiesBySensor = {};
    
    personalities.forEach(personality => {
      if (!personality.sensorId) return;
      
      if (!personalitiesBySensor[personality.sensorId]) {
        personalitiesBySensor[personality.sensorId] = [];
      }
      
      personalitiesBySensor[personality.sensorId].push(personality);
    });
    
    // Update each sensor's personality table
    for (const [sensorId, sensorPersonalities] of Object.entries(personalitiesBySensor)) {
      const personalityTable = document.getElementById(`personality-${sensorId}`);
      if (!personalityTable) continue;
      
      // Clear existing personality items
      personalityTable.innerHTML = '';
      
      // Add all personality items, newest first
      sensorPersonalities.forEach(item => handlePersonalityUpdate(item, false));
      
      console.log(`Updated personality table for sensor ${sensorId} with ${sensorPersonalities.length} items`);
    }
  }
  
  // Function to handle the refresh button click
  function refreshData(sensorId) {
    // Get the refresh button and add the spinning class
    const refreshBtn = event.currentTarget;
    refreshBtn.classList.add('spinning');
    
    console.log(`Requesting full data refresh for sensor ${sensorId}...`);
    
    // Request a full data refresh via socket
    const socket = io();
    socket.emit('requestFullData');
    
    // Set a timeout to remove the spinning class after 1 second
    setTimeout(() => {
      refreshBtn.classList.remove('spinning');
    }, 1000);
  }
  
  // Function to handle alert updates
  function handleAlert(data, addToTop = true) {
    if (!data || !data.sensorId) {
      console.warn('Invalid alert data received:', data);
      return;
    }
    
    console.log(`Processing alert for ${data.sensorId}:`, data);
    
    const alertsTable = document.getElementById(`alerts-${data.sensorId}`);
    if (!alertsTable) {
      console.warn(`Alert table not found for sensor ${data.sensorId}`);
      return;
    }
    
    // Create a new row for the alert
    const row = document.createElement('tr');
    row.className = data.eventType && String(data.eventType).includes('RECOVERY') ? 'alert-recovery' : 'alert-row';
    
    // Create row content
    row.innerHTML = `
      <td>${data.date || '-'}</td>
      <td>${data.time || '-'}</td>
      <td>${data.event || data.alertReason || '-'}</td>
    `;
    
    // Check for empty state and remove it if it exists
    const emptyRow = alertsTable.querySelector('.empty-table-row');
    if (emptyRow) {
      alertsTable.removeChild(emptyRow);
    }
    
    // Add to the beginning of the table
    alertsTable.insertBefore(row, alertsTable.firstChild);
    
    // Keep only the latest 10 rows
    while (alertsTable.children.length > 10) {
      alertsTable.removeChild(alertsTable.lastChild);
    }
    
    console.log(`Alert display updated for ${data.sensorId}`);
    
    // Show notification if appropriate
    showNotification(`ã‚¢ãƒ©ãƒ¼ãƒˆ: ${data.sensorId}`, data.event || data.alertReason || 'ã‚¢ãƒ©ãƒ¼ãƒˆãŒç™ºç”Ÿã—ã¾ã—ãŸ');
  }
  
  // Function to handle settings updates
  function handleSettingChange(data, addToTop = true) {
    if (!data || !data.sensorId) {
      console.warn('Invalid setting data received:', data);
      return;
    }
    
    console.log(`Processing setting change for ${data.sensorId}:`, data);
    
    const settingsTable = document.getElementById(`settings-${data.sensorId}`);
    if (!settingsTable) {
      console.warn(`Settings table not found for sensor ${data.sensorId}`);
      return;
    }
    
    // Format the content
    let content = data.content;
    if (!content && data.changeType) {
      if (data.changeType === 'threshold' && data.value) {
        const { high, low } = data.value;
        content = `ã—ãã„å€¤ï¼ˆé«˜: ${high}Â°C / ä½: ${low}Â°Cï¼‰`;
      } else if (data.changeType === 'interval' && data.value) {
        content = `èª­å–é–“éš”å¤‰æ›´: ${data.value}ms`;
      } else {
        content = `${data.changeType}ã®è¨­å®šå¤‰æ›´`;
      }
    }
    
    // Create a new row
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${data.date || '-'}</td>
      <td>${data.time || '-'}</td>
      <td>${content || '-'}</td>
    `;
    
    // Check for empty state and remove it if it exists
    const emptyRow = settingsTable.querySelector('.empty-table-row');
    if (emptyRow) {
      settingsTable.removeChild(emptyRow);
    }
    
    // Add to the beginning of the table
    settingsTable.insertBefore(row, settingsTable.firstChild);
    
    // Keep only the latest 10 rows
    while (settingsTable.children.length > 10) {
      settingsTable.removeChild(settingsTable.lastChild);
    }
    
    console.log(`Settings display updated for ${data.sensorId}`);
  }
  
  // Function to handle personality updates
  function handlePersonalityUpdate(data, addToTop = true) {
    if (!data || !data.sensorId) {
      console.warn('Invalid personality data received:', data);
      return;
    }
    
    console.log(`Processing personality update for ${data.sensorId}:`, data);
    
    const personalityTable = document.getElementById(`personality-${data.sensorId}`);
    if (!personalityTable) {
      console.warn(`Personality table not found for sensor ${data.sensorId}`);
      return;
    }
    
    // Format the content
    let content = data.content;
    if (!content && data.biasType) {
      if (data.biasType === 'temperature_offset' && data.biasValue) {
        const offset = data.biasValue.offset;
        const sign = offset > 0 ? '+' : '';
        content = `æ¸©åº¦è£œæ­£ãƒã‚¤ã‚¢ã‚¹: ${sign}${offset}Â°C`;
      } else if (data.biasType === 'sensitivity' && data.biasValue) {
        content = `æ„Ÿåº¦è¨­å®š: ${data.biasValue.level}`;
      } else {
        content = `${data.biasType}ã®è¨­å®š`;
      }
    }
    
    // Create a new row
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${data.date || '-'}</td>
      <td>${data.time || '-'}</td>
      <td>${content || '-'}</td>
    `;
    
    // Check for empty state and remove it if it exists
    const emptyRow = personalityTable.querySelector('.empty-table-row');
    if (emptyRow) {
      personalityTable.removeChild(emptyRow);
    }
    
    // Add to the beginning of the table
    personalityTable.insertBefore(row, personalityTable.firstChild);
    
    // Keep only the latest 10 rows
    while (personalityTable.children.length > 10) {
      personalityTable.removeChild(personalityTable.lastChild);
    }
    
    console.log(`Personality display updated for ${data.sensorId}`);
  }
  
  // Show browser notifications if supported
  function showNotification(title, body) {
    if (!("Notification" in window)) {
      console.log("Browser does not support notifications");
      return;
    }
    
    if (Notification.permission === "granted") {
      new Notification(title, { body });
    } else if (Notification.permission !== "denied") {
      Notification.requestPermission().then(permission => {
        if (permission === "granted") {
          new Notification(title, { body });
        }
      });
    }
  }
  
  // Tab switching logic
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM content loaded, initializing UI...');
    
    // Socket.IO event listeners for full dataset updates
    const socket = io();
    
    socket.on('fullSensorData', handleFullSensorData);
    socket.on('fullAlertsData', handleFullAlertsData);
    socket.on('fullSettingsData', handleFullSettingsData);
    socket.on('fullPersonalityData', handleFullPersonalityData);
    
    // Listen for notifications about new data
    socket.on('newDataAvailable', (data) => {
      console.log(`New data notification: ${data.count} new readings for sensor ${data.sensorId}`);
      // You could show a notification to the user here
      showNotification('æ–°è¦ãƒ‡ãƒ¼ã‚¿ã‚ã‚Š', `ã‚»ãƒ³ã‚µãƒ¼ ${data.sensorId} ã« ${data.count} ä»¶ã®æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™`);
    });
    
    socket.on('dataUpdated', (data) => {
      console.log(`Data updated at ${new Date(data.timestamp).toLocaleTimeString()}`);
      // Update the last updated timestamp in the UI
      const lastUpdatedElement = document.getElementById('status-last-updated');
      if (lastUpdatedElement) {
        lastUpdatedElement.textContent = `æœ€çµ‚æ›´æ–°: ${new Date(data.timestamp).toLocaleString('ja-JP')}`;
      }
    });
    
    // Set initial active tab
    const defaultTab = 'sensorTab';
    const defaultBtn = document.getElementById('sensorTabBtn');
    switchTab(defaultTab, defaultBtn);

    // Initialize all expand/collapse buttons with proper state
    document.querySelectorAll('.section-header .expand-btn').forEach(btn => {
      const wrapperId = btn.getAttribute('onclick')?.match(/['"](.*?)['"]/)?.[1];
      if (wrapperId) {
        const wrapper = document.getElementById(wrapperId);
        if (wrapper) {
          updateExpandButtonText(btn, wrapper.classList.contains('expanded'));
        }
      }
    });
    
    // Initialize history tables
    initializeHistoryTables();
    
    // Add scroll detection for table wrappers
    document.querySelectorAll('.table-wrapper').forEach(wrapper => {
      wrapper.addEventListener('scroll', () => {
        const hasMore = wrapper.scrollHeight > wrapper.clientHeight + 10;
        wrapper.classList.toggle('has-more-content', hasMore);
      });
    });
    
    console.log('UI initialization complete');
  });

  function switchTab(tabId, buttonElement) {
    if (!tabId || !buttonElement) return;
    
    // Remove active class from all tabs and buttons
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.style.display = 'none';
        tab.classList.remove('active');
    });
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show selected tab and activate button
    const selectedTab = document.getElementById(tabId);
    if (selectedTab) {
      selectedTab.style.display = 'block';
      selectedTab.classList.add('active');
      buttonElement.classList.add('active');
      
      // Store the active tab in localStorage
      localStorage.setItem('activeTab', tabId);
      localStorage.setItem('activeTabBtn', buttonElement.id);
    }
  }

  // Restore tab state on page load
  window.addEventListener('load', () => {
    const savedTab = localStorage.getItem('activeTab');
    const savedTabBtn = localStorage.getItem('activeTabBtn');
    if (savedTab && savedTabBtn) {
      const btn = document.getElementById(savedTabBtn);
      if (btn) {
        switchTab(savedTab, btn);
      }
    }
  });

  // Updated function to toggle table expansion with animation
  function toggleTableExpand(wrapperId) {
    const wrapper = document.getElementById(wrapperId);
    if (!wrapper) return;
    
    // Toggle expanded class
    wrapper.classList.toggle('expanded');
    
    // Update button text
    const isExpanded = wrapper.classList.contains('expanded');
    const btn = event.currentTarget;
    const toggleIcon = btn.querySelector('.toggle-icon');
    const toggleText = btn.querySelector('.toggle-text');
    
    if (toggleIcon) toggleIcon.textContent = isExpanded ? 'âŒƒ' : 'âŒ„';
    if (toggleText) toggleText.textContent = isExpanded ? 'æŠ˜ã‚ŠãŸãŸã‚€' : 'å±•é–‹';
    
    btn.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
    
    // Check for scroll content after expansion
    setTimeout(() => {
      const hasMoreContent = wrapper.scrollHeight > wrapper.clientHeight + 10;
      wrapper.classList.toggle('has-more-content', hasMoreContent);
    }, 300); // Wait for animation to complete
  }

  // Function to update button text
  function updateExpandButtonText(btn, isExpanded) {
    const toggleIcon = btn.querySelector('.toggle-icon');
    const toggleText = btn.querySelector('.toggle-text');
    
    if (toggleIcon) toggleIcon.textContent = isExpanded ? 'âŒƒ' : 'âŒ„';
    if (toggleText) toggleText.textContent = isExpanded ? 'æŠ˜ã‚ŠãŸãŸã‚€' : 'å±•é–‹';
    
    btn.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
  }

  // Function to initialize all history tables
  function initializeHistoryTables() {
    document.querySelectorAll('.alert-table, .settings-table, .personality-table').forEach(wrapper => {
      // Check if the table has content
      const tableBody = wrapper.querySelector('tbody');
      const hasRows = tableBody && tableBody.children.length > 0 && !tableBody.querySelector('.empty-table-row');
      
      // Add appropriate classes based on content
      if (hasRows) {
        wrapper.classList.add('has-content');
        
        // Check if scrolling is needed
        const hasMoreContent = wrapper.scrollHeight > wrapper.clientHeight + 10;
        wrapper.classList.toggle('has-more-content', hasMoreContent);
      } else {
        wrapper.classList.add('empty');
      }
      
      // Set up expand button state
      const wrapperId = wrapper.id;
      if (wrapperId) {
        const btn = document.querySelector(`.expand-btn[onclick*="${wrapperId}"]`);
        if (btn) {
          updateExpandButtonText(btn, wrapper.classList.contains('expanded'));
        }
      }
    });
  }
  
  // Enhanced logging
  console.log('Sensor data script loaded and ready to receive updates');
</script>